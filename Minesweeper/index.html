<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minesweeper</title>
  <style>
    body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; }
    .board { display: grid; grid-template-rows: repeat(var(--rows), 32px); grid-template-columns: repeat(var(--cols), 32px); gap: 2px; }
    .cell {
      width: 32px; height: 32px; background: #bdbdbd; border: 1px solid #7b7b7b;
      display: flex; align-items: center; justify-content: center; font-size: 1.2em; cursor: pointer;
      user-select: none; outline: none;
    }
    .cell.revealed { background: #e0e0e0; cursor: default; }
    .cell.flagged { background: #ffecb3; }
    .cell.mine { background: #ff5252; color: #fff; }
    .cell:focus { box-shadow: 0 0 4px #1976d2; }
    .status { margin: 10px; font-weight: bold; }
    .controls { margin: 10px; }
  </style>
</head>
<body>
  <h2>Minesweeper</h2>
  <div class="controls">
    <label>Rows: <input type="number" id="rows" value="9" min="5" max="20"></label>
    <label>Columns: <input type="number" id="cols" value="9" min="5" max="20"></label>
    <label>Mines: <input type="number" id="mines" value="10" min="5" max="80"></label>
    <button id="restart">Restart</button>
  </div>
  <div class="status" id="status"></div>
  <div class="board" id="board"></div>
  <script>
    // Minesweeper core logic

    let rows = 9, cols = 9, mines = 10, board = [], revealed = [], flagged = [], gameOver = false, firstMove = true;

    const boardDiv = document.getElementById('board');
    const statusDiv = document.getElementById('status');
    function arr2d(val) { return Array.from({length: rows}, () => Array(cols).fill(val)); }

    function plantMines(x0, y0) {
      let placed = 0;
      while (placed < mines) {
        let x = Math.floor(Math.random() * rows);
        let y = Math.floor(Math.random() * cols);
        // Don't put a mine at the first-clicked cell or duplicate mines
        if ((x !== x0 || y !== y0) && board[x][y] !== 'M') {
          board[x][y] = 'M';
          placed++;
        }
      }
      // Fill numbers
      for (let x = 0; x < rows; x++) for (let y = 0; y < cols; y++) {
        if (board[x][y] !== 'M') {
          board[x][y] = countAdjacent(x, y);
        }
      }
    }

    function countAdjacent(x, y) {
      let count = 0;
      for (let dx = -1; dx <=1; dx++) for (let dy = -1; dy <=1; dy++) {
        let nx = x + dx, ny = y + dy;
        if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && board[nx] && board[nx][ny] === 'M') count++;
      }
      return count;
    }

    function newGame() {
      rows = +document.getElementById('rows').value;
      cols = +document.getElementById('cols').value;
      mines = Math.min(+document.getElementById('mines').value, rows * cols - 1);
      boardDiv.style.setProperty('--rows', rows);
      boardDiv.style.setProperty('--cols', cols);
      board = arr2d(0);
      revealed = arr2d(false);
      flagged = arr2d(false);
      gameOver = false;
      firstMove = true;
      statusDiv.textContent = '';
      render();
    }

    function revealCell(x, y) {
      if (gameOver || flagged[x][y] || revealed[x][y]) return;
      if (firstMove) {
        plantMines(x, y);
        firstMove = false;
      }
      revealed[x][y] = true;
      // Mine: lose
      if (board[x][y] === 'M') {
        statusDiv.textContent = 'ðŸ’¥ Game Over!';
        gameOver = true;
        revealAll();
        render();
        return;
      }
      // Empty: flood reveal
      if (board[x][y] === 0) {
        for (let dx = -1; dx <=1; dx++) for (let dy = -1; dy <=1; dy++) {
          let nx = x + dx, ny = y + dy;
          if (
            nx >= 0 && nx < rows && ny >= 0 && ny < cols &&
            !revealed[nx][ny] && !flagged[nx][ny]
          ) {
            revealCell(nx, ny);
          }
        }
      }
      checkWin();
      render();
    }

    function revealAll() {
      for (let x = 0; x < rows; x++) for (let y = 0; y < cols; y++) revealed[x][y] = true;
    }

    function flagCell(x, y) {
      if (gameOver || revealed[x][y]) return;
      flagged[x][y] = !flagged[x][y];
      render();
    }

    function checkWin() {
      let safeCount = 0;
      for (let x = 0; x < rows; x++) for (let y = 0; y < cols; y++) {
        if (!revealed[x][y] && board[x][y] !== 'M') safeCount++;
      }
      if (safeCount === 0 && !gameOver) {
        statusDiv.textContent = 'ðŸŽ‰ You Win!';
        gameOver = true;
        revealAll();
      }
    }

    function render() {
      boardDiv.innerHTML = '';
      for (let x = 0; x < rows; x++) for (let y = 0; y < cols; y++) {
        const cell = document.createElement('button');
        cell.classList.add('cell');
        cell.tabIndex = 0;
        cell.dataset.x = x;
        cell.dataset.y = y;
        if (revealed[x][y]) {
          cell.classList.add('revealed');
          if (board[x][y] === 'M') {
            cell.classList.add('mine');
            cell.textContent = 'ðŸ’£';
          } else if (board[x][y] > 0) {
            cell.style.color = ['#2e7d32','#1565c0','#ad1457','#fbc02d','#00838f','#6d4c41','#c62828','#212121'][board[x][y]-1];
            cell.textContent = board[x][y];
          } else {
            cell.textContent = '';
          }
        } else if (flagged[x][y]) {
          cell.classList.add('flagged');
          cell.textContent = 'ðŸš©';
        } else {
          cell.textContent = '';
        }
        cell.addEventListener('click', (e) => {
          revealCell(x, y);
        });
        cell.addEventListener('keydown', (e) => {
          if (e.code === 'Space') { // Spacebar: flag
            flagCell(x, y);
            e.preventDefault();
          } else if (e.code === 'Enter') {
            revealCell(x, y);
            e.preventDefault();
          }
        });
        cell.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          flagCell(x, y);
        });
        boardDiv.appendChild(cell);
      }
    }

    document.getElementById('restart').addEventListener('click', newGame);

    // Arrows navigation
    boardDiv.addEventListener('keydown', (e) => {
      let focused = document.activeElement;
      if (!focused.classList.contains('cell')) return;
      let x = +focused.dataset.x, y = +focused.dataset.y;
      if (e.code === 'ArrowRight') y = (y+1)%cols;
      if (e.code === 'ArrowLeft') y = (y-1+cols)%cols;
      if (e.code === 'ArrowDown') x = (x+1)%rows;
      if (e.code === 'ArrowUp') x = (x-1+rows)%rows;
      let nextCell = Array.from(boardDiv.children).find(c => +c.dataset.x===x && +c.dataset.y===y);
      if (nextCell) { nextCell.focus(); e.preventDefault();}
    });

    newGame();
  </script>
</body>
</html>
